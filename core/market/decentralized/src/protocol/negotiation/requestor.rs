use std::sync::Arc;

use super::super::callbacks::{CallbackHandler, HandlerSlot};
use super::errors::{AgreementError, NegotiationApiInitError, ProposalError};
use super::messages::{AgreementApproved, AgreementRejected, ProposalReceived, ProposalRejected};

/// Responsible for communication with markets on other nodes
/// during negotiation phase.
#[derive(Clone)]
pub struct NegotiationApi {
    inner: Arc<NegotiationImpl>,
}

struct NegotiationImpl {
    proposal_received: HandlerSlot<ProposalReceived>,
    proposal_rejected: HandlerSlot<ProposalRejected>,
    agreement_approved: HandlerSlot<AgreementApproved>,
    agreement_rejected: HandlerSlot<AgreementRejected>,
}

impl NegotiationApi {
    pub fn new(
        proposal_received: impl CallbackHandler<ProposalReceived>,
        proposal_rejected: impl CallbackHandler<ProposalRejected>,
        agreement_approved: impl CallbackHandler<AgreementApproved>,
        agreement_rejected: impl CallbackHandler<AgreementRejected>,
    ) -> NegotiationApi {
        let negotiation_impl = NegotiationImpl {
            proposal_received: HandlerSlot::new(proposal_received),
            proposal_rejected: HandlerSlot::new(proposal_rejected),
            agreement_approved: HandlerSlot::new(agreement_approved),
            agreement_rejected: HandlerSlot::new(agreement_rejected),
        };
        NegotiationApi {
            inner: Arc::new(negotiation_impl),
        }
    }

    pub async fn bind_gsb(
        &self,
        public_prefix: &str,
        private_prefix: &str,
    ) -> Result<(), NegotiationApiInitError> {
        // TODO: Implement.
        Ok(())
    }

    /// Sent to provider, when Requestor counters initial proposal
    /// generated by market.
    pub async fn initial_proposal(&self) -> Result<(), ProposalError> {
        unimplemented!()
    }

    /// Counter proposals used in all other cases, when proposal
    /// is not in initial state.
    pub async fn counter_proposal(&self) -> Result<(), ProposalError> {
        unimplemented!()
    }

    pub async fn reject_proposal(&self) -> Result<(), ProposalError> {
        unimplemented!()
    }

    /// Sent to provider, when Requestor will call confirm Agreement.
    pub async fn propose_agreement(&self) -> Result<(), AgreementError> {
        unimplemented!()
    }

    /// Sent to provider, when Requestor will call cancel Agreement,
    /// while waiting for approval.
    pub async fn cancel_agreement(&self) -> Result<(), AgreementError> {
        unimplemented!()
    }
}
